#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <time.h>
#include <libpq-fe.h>

#define PORT 8080
#define BUFFER_SIZE 4096

// Global variables
PGconn *conn = NULL;
time_t last_update = 0;
int total_connections = 0;
int active_connections = 0;
int idle_connections = 0;
double cache_hit_ratio = 0.0;

// Database connection with retry logic
int connect_database() {
    const char *conninfo = "host=postgres port=5432 dbname=pganalytics user=admin password=admin123 connect_timeout=10";
    
    if (conn) {
        PQfinish(conn);
        conn = NULL;
    }
    
    printf("üîó Tentando conectar ao PostgreSQL...
");
    conn = PQconnectdb(conninfo);
    
    if (PQstatus(conn) != CONNECTION_OK) {
        printf("‚ùå Falha na conex√£o: %s", PQerrorMessage(conn));
        PQfinish(conn);
        conn = NULL;
        return 0;
    }
    
    printf("‚úÖ Conectado ao PostgreSQL!
");
    return 1;
}

// Collect real metrics from PostgreSQL
void collect_real_metrics() {
    if (!conn || PQstatus(conn) != CONNECTION_OK) {
        if (!connect_database()) {
            return;
        }
    }
    
    // Test connection with simple query
    PGresult *test = PQexec(conn, "SELECT 1");
    if (PQresultStatus(test) != PGRES_TUPLES_OK) {
        printf("‚ö†Ô∏è  Conex√£o perdida, tentando reconectar...
");
        PQclear(test);
        if (!connect_database()) {
            return;
        }
    } else {
        PQclear(test);
    }
    
    // Get connection statistics
    PGresult *res = PQexec(conn, 
        "SELECT "
        "  COUNT(*) as total, "
        "  COUNT(CASE WHEN state = 'active' THEN 1 END) as active, "
        "  COUNT(CASE WHEN state = 'idle' THEN 1 END) as idle "
        "FROM pg_stat_activity WHERE pid <> pg_backend_pid()"
    );
    
    if (PQresultStatus(res) == PGRES_TUPLES_OK && PQntuples(res) > 0) {
        total_connections = atoi(PQgetvalue(res, 0, 0));
        active_connections = atoi(PQgetvalue(res, 0, 1));
        idle_connections = atoi(PQgetvalue(res, 0, 2));
        printf("üìä Conex√µes: %d total, %d ativas, %d idle
", 
               total_connections, active_connections, idle_connections);
    } else {
        printf("‚ö†Ô∏è  Erro ao consultar conex√µes: %s
", PQerrorMessage(conn));
    }
    PQclear(res);
    
    // Get cache hit ratio
    res = PQexec(conn,
        "SELECT "
        "  ROUND("
        "    CASE WHEN (blks_hit + blks_read) > 0 "
        "    THEN blks_hit::numeric / (blks_hit + blks_read) "
        "    ELSE 0 END, 4"
        "  ) as cache_hit_ratio "
        "FROM pg_stat_database WHERE datname = current_database()"
    );
    
    if (PQresultStatus(res) == PGRES_TUPLES_OK && PQntuples(res) > 0) {
        cache_hit_ratio = atof(PQgetvalue(res, 0, 0));
        printf("üìà Cache hit ratio: %.2f%%
", cache_hit_ratio * 100);
    }
    PQclear(res);
    
    last_update = time(NULL);
    printf("‚úÖ M√©tricas coletadas com sucesso!
");
}

// Generate Prometheus metrics
void send_metrics(int client_socket) {
    char response[BUFFER_SIZE];
    char body[BUFFER_SIZE];
    
    // Generate metrics
    snprintf(body, sizeof(body),
        "# HELP pganalytics_collector_info Information about the collector
"
        "# TYPE pganalytics_collector_info gauge
"
        "pganalytics_collector_info{version="1.0",type="c-bypass"} 1
"
        "
"
        "# HELP pganalytics_collector_last_update Last metrics update timestamp
"
        "# TYPE pganalytics_collector_last_update gauge
"
        "pganalytics_collector_last_update %ld
"
        "
"
        "# HELP pganalytics_postgresql_connections Number of PostgreSQL connections
"
        "# TYPE pganalytics_postgresql_connections gauge
"
        "pganalytics_postgresql_connections{state="total"} %d
"
        "pganalytics_postgresql_connections{state="active"} %d
"
        "pganalytics_postgresql_connections{state="idle"} %d
"
        "
"
        "# HELP pganalytics_postgresql_cache_hit_ratio PostgreSQL cache hit ratio
"
        "# TYPE pganalytics_postgresql_cache_hit_ratio gauge
"
        "pganalytics_postgresql_cache_hit_ratio %.4f
"
        "
"
        "# HELP pganalytics_postgresql_database_connected Database connection status
"
        "# TYPE pganalytics_postgresql_database_connected gauge
"
        "pganalytics_postgresql_database_connected %d
",
        last_update,
        total_connections,
        active_connections, 
        idle_connections,
        cache_hit_ratio,
        (conn && PQstatus(conn) == CONNECTION_OK) ? 1 : 0
    );
    
    // Send HTTP response
    snprintf(response, sizeof(response),
        "HTTP/1.1 200 OK
"
        "Content-Type: text/plain; version=0.0.4
"
        "Content-Length: %ld
"
        "Connection: close

%s",
        strlen(body), body);
    
    send(client_socket, response, strlen(response), 0);
}

// Generate health check response
void send_health(int client_socket) {
    char response[BUFFER_SIZE];
    char body[512];
    
    time_t now = time(NULL);
    int db_connected = (conn && PQstatus(conn) == CONNECTION_OK) ? 1 : 0;
    int data_age = (int)(now - last_update);
    
    const char* status = db_connected ? "healthy" : "unhealthy";
    
    // Generate JSON health response
    snprintf(body, sizeof(body),
        "{
"
        "  "status": "%s",
"
        "  "timestamp": %ld,
"
        "  "database_connected": %s,
"
        "  "last_update": %ld,
"
        "  "data_age_seconds": %d,
"
        "  "version": "1.0",
"
        "  "type": "c-bypass",
"
        "  "metrics": {
"
        "    "total_connections": %d,
"
        "    "active_connections": %d,
"
        "    "cache_hit_ratio": %.4f
"
        "  }
"
        "}",
        status, now, db_connected ? "true" : "false", 
        last_update, data_age,
        total_connections, active_connections, cache_hit_ratio
    );
    
    // Send HTTP response
    snprintf(response, sizeof(response),
        "HTTP/1.1 200 OK
"
        "Content-Type: application/json
"
        "Content-Length: %ld
"
        "Connection: close

%s",
        strlen(body), body);
    
    send(client_socket, response, strlen(response), 0);
}

// Send root page
void send_root(int client_socket) {
    const char* body = "PG Analytics C Collector v1.0
"
                      "===============================
"
                      "Status: Running
"
                      "Database: PostgreSQL

"
                      "Endpoints:
"
                      "  /health  - Health check (JSON)
"
                      "  /metrics - Prometheus metrics
"
                      "  /        - This information
";
    
    char response[BUFFER_SIZE];
    snprintf(response, sizeof(response),
        "HTTP/1.1 200 OK
"
        "Content-Type: text/plain
"
        "Content-Length: %ld
"
        "Connection: close

%s",
        strlen(body), body);
    
    send(client_socket, response, strlen(response), 0);
}

// Handle HTTP requests
void handle_request(int client_socket) {
    char buffer[BUFFER_SIZE];
    ssize_t bytes_read = recv(client_socket, buffer, BUFFER_SIZE - 1, 0);
    
    if (bytes_read <= 0) {
        close(client_socket);
        return;
    }
    
    buffer[bytes_read] = '';
    
    // Parse HTTP request
    char method[16], path[256], version[16];
    if (sscanf(buffer, "%15s %255s %15s", method, path, version) != 3) {
        close(client_socket);
        return;
    }
    
    printf("üì• %s %s
", method, path);
    
    // Route requests
    if (strcmp(path, "/metrics") == 0) {
        send_metrics(client_socket);
    } else if (strcmp(path, "/health") == 0) {
        send_health(client_socket);
    } else if (strcmp(path, "/") == 0) {
        send_root(client_socket);
    } else {
        // 404 Not Found
        const char* not_found = "HTTP/1.1 404 Not Found
"
                               "Content-Type: text/plain
"
                               "Connection: close

"
                               "404 Not Found
";
        send(client_socket, not_found, strlen(not_found), 0);
    }
    
    close(client_socket);
}

int main() {
    printf("üöÄ PG Analytics C Collector v1.0 iniciando...
");
    
    // Try initial database connection
    if (connect_database()) {
        printf("‚úÖ Conex√£o inicial com banco estabelecida
");
    } else {
        printf("‚ö†Ô∏è  Conex√£o inicial falhou, tentaremos novamente durante opera√ß√£o
");
    }
    
    // Create socket
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        perror("socket");
        return 1;
    }
    
    // Set socket options
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    
    // Bind socket
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);
    
    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        perror("bind");
        close(server_socket);
        return 1;
    }
    
    // Listen
    if (listen(server_socket, 10) == -1) {
        perror("listen");
        close(server_socket);
        return 1;
    }
    
    printf("‚úÖ Servidor iniciado na porta %d
", PORT);
    printf("üìä Endpoints: /health /metrics /
");
    
    // Collect initial metrics
    collect_real_metrics();
    
    // Main server loop
    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);
        
        int client_socket = accept(server_socket, (struct sockaddr*)&client_addr, &client_len);
        if (client_socket == -1) {
            perror("accept");
            continue;
        }
        
        handle_request(client_socket);
        
        // Collect metrics periodically (every 10 requests or so)
        static int request_count = 0;
        if (++request_count % 10 == 0) {
            collect_real_metrics();
        }
    }
    
    // Cleanup
    close(server_socket);
    if (conn) PQfinish(conn);
    
    return 0;
}
