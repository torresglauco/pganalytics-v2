#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <time.h>
#include <libpq-fe.h>

#define PORT 8080
#define BUFFER_SIZE 4096

// Global variables
PGconn *conn = NULL;
time_t last_update = 0;
int total_connections = 0;
int active_connections = 0;
int idle_connections = 0;
double cache_hit_ratio = 0.0;

// Database connection with retry logic
int connect_database() {
    const char *conninfo = "host=postgres port=5432 dbname=pganalytics user=admin password=admin123 connect_timeout=10";
    
    if (conn) {
        PQfinish(conn);
        conn = NULL;
    }
    
    printf("Connecting to PostgreSQL...\n");
    conn = PQconnectdb(conninfo);
    
    if (PQstatus(conn) != CONNECTION_OK) {
        printf("Connection failed: %s", PQerrorMessage(conn));
        PQfinish(conn);
        conn = NULL;
        return 0;
    }
    
    printf("Connected to PostgreSQL successfully!\n");
    return 1;
}

// Collect real metrics from PostgreSQL
void collect_real_metrics() {
    if (!conn || PQstatus(conn) != CONNECTION_OK) {
        if (!connect_database()) {
            return;
        }
    }
    
    // Test connection with simple query
    PGresult *test = PQexec(conn, "SELECT 1");
    if (PQresultStatus(test) != PGRES_TUPLES_OK) {
        printf("Connection lost, trying to reconnect...\n");
        PQclear(test);
        if (!connect_database()) {
            return;
        }
    } else {
        PQclear(test);
    }
    
    // Get connection statistics
    PGresult *res = PQexec(conn, 
        "SELECT "
        "  COUNT(*) as total, "
        "  COUNT(CASE WHEN state = 'active' THEN 1 END) as active, "
        "  COUNT(CASE WHEN state = 'idle' THEN 1 END) as idle "
        "FROM pg_stat_activity WHERE pid <> pg_backend_pid()"
    );
    
    if (PQresultStatus(res) == PGRES_TUPLES_OK && PQntuples(res) > 0) {
        total_connections = atoi(PQgetvalue(res, 0, 0));
        active_connections = atoi(PQgetvalue(res, 0, 1));
        idle_connections = atoi(PQgetvalue(res, 0, 2));
        printf("Connections: %d total, %d active, %d idle\n", 
               total_connections, active_connections, idle_connections);
    } else {
        printf("Error querying connections: %s\n", PQerrorMessage(conn));
    }
    PQclear(res);
    
    // Get cache hit ratio
    res = PQexec(conn,
        "SELECT "
        "  ROUND("
        "    CASE WHEN (blks_hit + blks_read) > 0 "
        "    THEN blks_hit::numeric / (blks_hit + blks_read) "
        "    ELSE 0 END, 4"
        "  ) as cache_hit_ratio "
        "FROM pg_stat_database WHERE datname = current_database()"
    );
    
    if (PQresultStatus(res) == PGRES_TUPLES_OK && PQntuples(res) > 0) {
        cache_hit_ratio = atof(PQgetvalue(res, 0, 0));
        printf("Cache hit ratio: %.2f%%\n", cache_hit_ratio * 100);
    }
    PQclear(res);
    
    last_update = time(NULL);
    printf("Metrics collected successfully!\n");
}

// Generate Prometheus metrics
void send_metrics(int client_socket) {
    char response[BUFFER_SIZE];
    char body[BUFFER_SIZE];
    
    // Generate metrics
    snprintf(body, sizeof(body),
        "# HELP pganalytics_collector_info Information about the collector\n"
        "# TYPE pganalytics_collector_info gauge\n"
        "pganalytics_collector_info{version=\"1.0\",type=\"c-bypass\"} 1\n"
        "\n"
        "# HELP pganalytics_collector_last_update Last metrics update timestamp\n"
        "# TYPE pganalytics_collector_last_update gauge\n"
        "pganalytics_collector_last_update %ld\n"
        "\n"
        "# HELP pganalytics_postgresql_connections Number of PostgreSQL connections\n"
        "# TYPE pganalytics_postgresql_connections gauge\n"
        "pganalytics_postgresql_connections{state=\"total\"} %d\n"
        "pganalytics_postgresql_connections{state=\"active\"} %d\n"
        "pganalytics_postgresql_connections{state=\"idle\"} %d\n"
        "\n"
        "# HELP pganalytics_postgresql_cache_hit_ratio PostgreSQL cache hit ratio\n"
        "# TYPE pganalytics_postgresql_cache_hit_ratio gauge\n"
        "pganalytics_postgresql_cache_hit_ratio %.4f\n"
        "\n"
        "# HELP pganalytics_postgresql_database_connected Database connection status\n"
        "# TYPE pganalytics_postgresql_database_connected gauge\n"
        "pganalytics_postgresql_database_connected %d\n",
        last_update,
        total_connections,
        active_connections, 
        idle_connections,
        cache_hit_ratio,
        (conn && PQstatus(conn) == CONNECTION_OK) ? 1 : 0
    );
    
    // Send HTTP response
    snprintf(response, sizeof(response),
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/plain; version=0.0.4\r\n"
        "Content-Length: %ld\r\n"
        "Connection: close\r\n\r\n%s",
        strlen(body), body);
    
    send(client_socket, response, strlen(response), 0);
}

// Generate health check response
void send_health(int client_socket) {
    char response[BUFFER_SIZE];
    char body[512];
    
    time_t now = time(NULL);
    int db_connected = (conn && PQstatus(conn) == CONNECTION_OK) ? 1 : 0;
    int data_age = (int)(now - last_update);
    
    const char* status = db_connected ? "healthy" : "unhealthy";
    
    // Generate JSON health response
    snprintf(body, sizeof(body),
        "{\n"
        "  \"status\": \"%s\",\n"
        "  \"timestamp\": %ld,\n"
        "  \"database_connected\": %s,\n"
        "  \"last_update\": %ld,\n"
        "  \"data_age_seconds\": %d,\n"
        "  \"version\": \"1.0\",\n"
        "  \"type\": \"c-bypass\",\n"
        "  \"metrics\": {\n"
        "    \"total_connections\": %d,\n"
        "    \"active_connections\": %d,\n"
        "    \"cache_hit_ratio\": %.4f\n"
        "  }\n"
        "}",
        status, now, db_connected ? "true" : "false", 
        last_update, data_age,
        total_connections, active_connections, cache_hit_ratio
    );
    
    // Send HTTP response
    snprintf(response, sizeof(response),
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: application/json\r\n"
        "Content-Length: %ld\r\n"
        "Connection: close\r\n\r\n%s",
        strlen(body), body);
    
    send(client_socket, response, strlen(response), 0);
}

// Send root page
void send_root(int client_socket) {
    const char* body = "PG Analytics C Collector v1.0\n"
                      "===============================\n"
                      "Status: Running\n"
                      "Database: PostgreSQL\n\n"
                      "Endpoints:\n"
                      "  /health  - Health check (JSON)\n"
                      "  /metrics - Prometheus metrics\n"
                      "  /        - This information\n";
    
    char response[BUFFER_SIZE];
    snprintf(response, sizeof(response),
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/plain\r\n"
        "Content-Length: %ld\r\n"
        "Connection: close\r\n\r\n%s",
        strlen(body), body);
    
    send(client_socket, response, strlen(response), 0);
}

// Handle HTTP requests
void handle_request(int client_socket) {
    char buffer[BUFFER_SIZE];
    ssize_t bytes_read = recv(client_socket, buffer, BUFFER_SIZE - 1, 0);
    
    if (bytes_read <= 0) {
        close(client_socket);
        return;
    }
    
    buffer[bytes_read] = '\0';
    
    // Parse HTTP request
    char method[16], path[256], version[16];
    if (sscanf(buffer, "%15s %255s %15s", method, path, version) != 3) {
        close(client_socket);
        return;
    }
    
    printf("Request: %s %s\n", method, path);
    
    // Route requests
    if (strcmp(path, "/metrics") == 0) {
        send_metrics(client_socket);
    } else if (strcmp(path, "/health") == 0) {
        send_health(client_socket);
    } else if (strcmp(path, "/") == 0) {
        send_root(client_socket);
    } else {
        // 404 Not Found
        const char* not_found = "HTTP/1.1 404 Not Found\r\n"
                               "Content-Type: text/plain\r\n"
                               "Connection: close\r\n\r\n"
                               "404 Not Found\n";
        send(client_socket, not_found, strlen(not_found), 0);
    }
    
    close(client_socket);
}

int main() {
    printf("PG Analytics C Collector v1.0 starting...\n");
    
    // Try initial database connection
    if (connect_database()) {
        printf("Initial database connection established\n");
    } else {
        printf("Initial connection failed, will retry during operation\n");
    }
    
    // Create socket
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket == -1) {
        perror("socket");
        return 1;
    }
    
    // Set socket options
    int opt = 1;
    setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    
    // Bind socket
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);
    
    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {
        perror("bind");
        close(server_socket);
        return 1;
    }
    
    // Listen
    if (listen(server_socket, 10) == -1) {
        perror("listen");
        close(server_socket);
        return 1;
    }
    
    printf("Server started on port %d\n", PORT);
    printf("Endpoints: /health /metrics /\n");
    
    // Collect initial metrics
    collect_real_metrics();
    
    // Main server loop
    while (1) {
        struct sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);
        
        int client_socket = accept(server_socket, (struct sockaddr*)&client_addr, &client_len);
        if (client_socket == -1) {
            perror("accept");
            continue;
        }
        
        handle_request(client_socket);
        
        // Collect metrics periodically (every 10 requests or so)
        static int request_count = 0;
        if (++request_count % 10 == 0) {
            collect_real_metrics();
        }
    }
    
    // Cleanup
    close(server_socket);
    if (conn) PQfinish(conn);
    
    return 0;
}
