#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <time.h>
#include <libpq-fe.h>
#include <pthread.h>
#include <errno.h>
#include <signal.h>

#define PORT 8080
#define BUFFER_SIZE 4096
#define MAX_CONNECTIONS 100

// Estruturas globais para métricas
typedef struct {
    int total_connections;
    int active_connections;
    float cache_hit_ratio;
    time_t last_update;
    int database_connected;
} metrics_t;

static metrics_t global_metrics = {0};
static pthread_mutex_t metrics_mutex = PTHREAD_MUTEX_INITIALIZER;
static int running = 1;

// Configurações do banco
static const char* db_host = "pganalytics-postgres";
static const char* db_port = "5432";
static const char* db_name = "pganalytics";
static const char* db_user = "pganalytics";
static const char* db_password = "pganalytics123";

// Forward declarations
void handle_request(int client_socket);
void send_response(int socket, const char* status, const char* content_type, const char* body);
void send_file_response(int socket, const char* content_type, const char* content);
void* metrics_collector_thread(void* arg);
void update_metrics();
int connect_database();
void signal_handler(int sig);

// Conteúdo da documentação OpenAPI
const char* openapi_json = \
"{"
"\"openapi\": \"3.0.3\","
"\"info\": {"
"\"title\": \"PG Analytics Collector API\","
"\"description\": \"API para coleta de métricas PostgreSQL em tempo real\","
"\"version\": \"1.0.0\""
"},"
"\"servers\": [{\"url\": \"http://localhost:8080\"}],"
"\"paths\": {"
"\"/\": {"
"\"get\": {"
"\"summary\": \"Root endpoint\","
"\"responses\": {\"200\": {\"description\": \"OK\"}}"
"}"
"},"
"\"/health\": {"
"\"get\": {"
"\"summary\": \"Health check\","
"\"responses\": {\"200\": {\"description\": \"Health status\"}}"
"}"
"},"
"\"/metrics\": {"
"\"get\": {"
"\"summary\": \"Prometheus metrics\","
"\"responses\": {\"200\": {\"description\": \"Metrics data\"}}"
"}"
"}"
"}"
"}";

// Conteúdo do Swagger UI
const char* swagger_html = \
"<!DOCTYPE html>"
"<html><head><title>PG Analytics API</title>"
"<link rel=\"stylesheet\" href=\"https://unpkg.com/swagger-ui-dist@3.52.5/swagger-ui.css\"/>"
"</head><body>"
"<div id=\"swagger-ui\"></div>"
"<script src=\"https://unpkg.com/swagger-ui-dist@3.52.5/swagger-ui-bundle.js\"></script>"
"<script>"
"SwaggerUIBundle({"
"url: '/openapi.json',"
"dom_id: '#swagger-ui',"
"presets: [SwaggerUIBundle.presets.apis]"
"});"
"</script></body></html>";

void signal_handler(int sig) {
    printf("\nShutting down collector...\n");
    running = 0;
}

int connect_database() {
    char conninfo[512];
    snprintf(conninfo, sizeof(conninfo), 
             "host=%s port=%s dbname=%s user=%s password=%s connect_timeout=10",
             db_host, db_port, db_name, db_user, db_password);
    
    PGconn *conn = PQconnectdb(conninfo);
    
    if (PQstatus(conn) != CONNECTION_OK) {
        printf("Database connection failed: %s\n", PQerrorMessage(conn));
        PQfinish(conn);
        return 0;
    }
    
    PQfinish(conn);
    return 1;
}

void update_metrics() {
    char conninfo[512];
    snprintf(conninfo, sizeof(conninfo), 
             "host=%s port=%s dbname=%s user=%s password=%s connect_timeout=5",
             db_host, db_port, db_name, db_user, db_password);
    
    PGconn *conn = PQconnectdb(conninfo);
    
    pthread_mutex_lock(&metrics_mutex);
    
    if (PQstatus(conn) == CONNECTION_OK) {
        global_metrics.database_connected = 1;
        
        // Query para total de conexões
        PGresult *res = PQexec(conn, "SELECT count(*) FROM pg_stat_activity;");
        if (PQresultStatus(res) == PGRES_TUPLES_OK && PQntuples(res) > 0) {
            global_metrics.total_connections = atoi(PQgetvalue(res, 0, 0));
        }
        PQclear(res);
        
        // Query para conexões ativas
        res = PQexec(conn, "SELECT count(*) FROM pg_stat_activity WHERE state = 'active';");
        if (PQresultStatus(res) == PGRES_TUPLES_OK && PQntuples(res) > 0) {
            global_metrics.active_connections = atoi(PQgetvalue(res, 0, 0));
        }
        PQclear(res);
        
        // Cache hit ratio
        res = PQexec(conn, "SELECT ROUND((sum(heap_blks_hit) / (sum(heap_blks_hit) + sum(heap_blks_read) + 1))::numeric, 4) FROM pg_statio_user_tables;");
        if (PQresultStatus(res) == PGRES_TUPLES_OK && PQntuples(res) > 0) {
            const char* ratio_str = PQgetvalue(res, 0, 0);
            if (ratio_str && strlen(ratio_str) > 0) {
                global_metrics.cache_hit_ratio = atof(ratio_str);
            } else {
                global_metrics.cache_hit_ratio = 0.98;  // Default value
            }
        }
        PQclear(res);
        
        global_metrics.last_update = time(NULL);
    } else {
        global_metrics.database_connected = 0;
        printf("Database connection failed: %s\n", PQerrorMessage(conn));
    }
    
    pthread_mutex_unlock(&metrics_mutex);
    
    if (conn) {
        PQfinish(conn);
    }
}

void* metrics_collector_thread(void* arg) {
    printf("Metrics collector thread started\n");
    
    while (running) {
        update_metrics();
        
        // Aguarda 30 segundos ou até o programa terminar
        for (int i = 0; i < 30 && running; i++) {
            sleep(1);
        }
    }
    
    printf("Metrics collector thread stopped\n");
    return NULL;
}

void send_response(int socket, const char* status, const char* content_type, const char* body) {
    char response[BUFFER_SIZE * 2];
    int body_length = body ? strlen(body) : 0;
    
    snprintf(response, sizeof(response),
        "HTTP/1.1 %s\r\n"
        "Content-Type: %s\r\n"
        "Content-Length: %d\r\n"
        "Access-Control-Allow-Origin: *\r\n"
        "Access-Control-Allow-Methods: GET, POST, OPTIONS\r\n"
        "Access-Control-Allow-Headers: Content-Type\r\n"
        "Connection: close\r\n"
        "\r\n"
        "%s",
        status, content_type, body_length, body ? body : "");
    
    send(socket, response, strlen(response), 0);
}

void send_file_response(int socket, const char* content_type, const char* content) {
    send_response(socket, "200 OK", content_type, content);
}

void handle_request(int client_socket) {
    char buffer[BUFFER_SIZE];
    int bytes_received = recv(client_socket, buffer, BUFFER_SIZE - 1, 0);
    
    if (bytes_received < 0) {
        printf("Error receiving request\n");
        close(client_socket);
        return;
    }
    
    buffer[bytes_received] = '\0';
    
    // Parse HTTP method and path
    char method[16], path[256];
    sscanf(buffer, "%s %s", method, path);
    
    printf("Request: %s %s\n", method, path);
    
    // Handle different endpoints
    if (strcmp(path, "/") == 0) {
        const char* response_body = 
            "{\"service\": \"pg-analytics-collector\", "
            "\"version\": \"1.0.0\", "
            "\"status\": \"running\", "
            "\"timestamp\": \"";
        
        char full_response[512];
        time_t now = time(NULL);
        snprintf(full_response, sizeof(full_response), 
                "%s%ld\"}", response_body, now);
        
        send_response(client_socket, "200 OK", "application/json", full_response);
        
    } else if (strcmp(path, "/health") == 0) {
        pthread_mutex_lock(&metrics_mutex);
        
        char health_response[1024];
        time_t now = time(NULL);
        int data_age = (int)(now - global_metrics.last_update);
        
        snprintf(health_response, sizeof(health_response),
            "{"
            "\"status\": \"healthy\", "
            "\"timestamp\": %ld, "
            "\"database_connected\": %s, "
            "\"last_update\": %ld, "
            "\"data_age_seconds\": %d, "
            "\"version\": \"1.0\", "
            "\"type\": \"c-bypass\", "
            "\"metrics\": {"
            "\"total_connections\": %d, "
            "\"active_connections\": %d, "
            "\"cache_hit_ratio\": %.4f"
            "}"
            "}",
            now,
            global_metrics.database_connected ? "true" : "false",
            global_metrics.last_update,
            data_age,
            global_metrics.total_connections,
            global_metrics.active_connections,
            global_metrics.cache_hit_ratio
        );
        
        pthread_mutex_unlock(&metrics_mutex);
        
        send_response(client_socket, "200 OK", "application/json", health_response);
        
    } else if (strcmp(path, "/metrics") == 0) {
        pthread_mutex_lock(&metrics_mutex);
        
        char metrics_response[2048];
        time_t now = time(NULL);
        
        snprintf(metrics_response, sizeof(metrics_response),
            "# HELP pganalytics_collector_info Information about the collector\n"
            "# TYPE pganalytics_collector_info gauge\n"
            "pganalytics_collector_info{version=\"1.0\",type=\"c-bypass\"} 1\n"
            "\n"
            "# HELP pganalytics_database_connected Database connection status\n"
            "# TYPE pganalytics_database_connected gauge\n"
            "pganalytics_database_connected %d\n"
            "\n"
            "# HELP pganalytics_total_connections Total database connections\n"
            "# TYPE pganalytics_total_connections gauge\n"
            "pganalytics_total_connections %d\n"
            "\n"
            "# HELP pganalytics_active_connections Active database connections\n"
            "# TYPE pganalytics_active_connections gauge\n"
            "pganalytics_active_connections %d\n"
            "\n"
            "# HELP pganalytics_cache_hit_ratio Database cache hit ratio\n"
            "# TYPE pganalytics_cache_hit_ratio gauge\n"
            "pganalytics_cache_hit_ratio %.4f\n"
            "\n"
            "# HELP pganalytics_last_update Last metrics update timestamp\n"
            "# TYPE pganalytics_last_update gauge\n"
            "pganalytics_last_update %ld\n",
            global_metrics.database_connected,
            global_metrics.total_connections,
            global_metrics.active_connections,
            global_metrics.cache_hit_ratio,
            global_metrics.last_update
        );
        
        pthread_mutex_unlock(&metrics_mutex);
        
        send_response(client_socket, "200 OK", "text/plain; version=0.0.4; charset=utf-8", metrics_response);
        
    } else if (strcmp(path, "/swagger") == 0 || strcmp(path, "/docs") == 0) {
        send_file_response(client_socket, "text/html; charset=utf-8", swagger_html);
        
    } else if (strcmp(path, "/openapi.json") == 0) {
        send_file_response(client_socket, "application/json", openapi_json);
        
    } else {
        const char* not_found_body = "{\"error\": \"Not Found\", \"path\": \"";
        char error_response[512];
        snprintf(error_response, sizeof(error_response), "%s%s\"}", not_found_body, path);
        
        send_response(client_socket, "404 Not Found", "application/json", error_response);
    }
    
    close(client_socket);
}

int main() {
    printf("PG Analytics C Collector v1.0 starting...\n");
    
    // Setup signal handlers
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    
    // Test database connection
    printf("Testing database connection...\n");
    if (!connect_database()) {
        printf("Warning: Database connection failed, continuing anyway\n");
    } else {
        printf("Database connection successful\n");
    }
    
    // Initial metrics update
    update_metrics();
    
    // Start metrics collector thread
    pthread_t metrics_thread;
    if (pthread_create(&metrics_thread, NULL, metrics_collector_thread, NULL) != 0) {
        printf("Failed to create metrics thread: %s\n", strerror(errno));
        return 1;
    }
    
    // Create socket
    int server_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (server_socket < 0) {
        printf("Error creating socket\n");
        return 1;
    }
    
    // Enable SO_REUSEADDR
    int opt = 1;
    if (setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0) {
        printf("Warning: setsockopt failed\n");
    }
    
    // Setup server address
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);
    
    // Bind socket
    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        printf("Error binding socket: %s\n", strerror(errno));
        close(server_socket);
        return 1;
    }
    
    // Listen for connections
    if (listen(server_socket, MAX_CONNECTIONS) < 0) {
        printf("Error listening: %s\n", strerror(errno));
        close(server_socket);
        return 1;
    }
    
    printf("C Collector server listening on port %d\n", PORT);
    printf("Available endpoints:\n");
    printf("  GET /          - Service info\n");
    printf("  GET /health    - Health check\n");
    printf("  GET /metrics   - Prometheus metrics\n");
    printf("  GET /swagger   - API documentation\n");
    printf("  GET /docs      - API documentation (alias)\n");
    printf("  GET /openapi.json - OpenAPI specification\n");
    
    // Main server loop
    while (running) {
        struct sockaddr_in client_addr;
        socklen_t client_len = sizeof(client_addr);
        
        int client_socket = accept(server_socket, (struct sockaddr*)&client_addr, &client_len);
        if (client_socket < 0) {
            if (running) {
                printf("Error accepting connection: %s\n", strerror(errno));
            }
            continue;
        }
        
        handle_request(client_socket);
    }
    
    // Cleanup
    printf("Shutting down server...\n");
    close(server_socket);
    
    // Wait for metrics thread to finish
    printf("Waiting for metrics thread...\n");
    pthread_join(metrics_thread, NULL);
    
    printf("Server stopped\n");
    return 0;
}
